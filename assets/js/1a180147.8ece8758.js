"use strict";(self.webpackChunkmirage_docs=self.webpackChunkmirage_docs||[]).push([[1183],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var a=t(67294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(t),h=s,w=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return t?a.createElement(w,r(r({ref:n},c),{},{components:t})):a.createElement(w,r({ref:n},c))}));function h(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var o=t.length,r=new Array(o);r[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5625:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=t(87462),s=(t(67294),t(3905));const o={sidebar_position:6,title:"Spawn Object - Custom"},r="Custom Spawn Functions",i={unversionedId:"guides/game-objects/spawn-object-custom",id:"guides/game-objects/spawn-object-custom",title:"Spawn Object - Custom",description:"You can use spawn handler functions to customize the default behavior when creating spawned game objects on the client. Spawn handler functions ensure you have full control of how you spawn the game object, as well as how you destroy it.",source:"@site/docs/guides/game-objects/spawn-object-custom.md",sourceDirName:"guides/game-objects",slug:"/guides/game-objects/spawn-object-custom",permalink:"/Mirage/docs/guides/game-objects/spawn-object-custom",draft:!1,editUrl:"https://github.com/MirageNet/Mirage/tree/main/doc/docs/guides/game-objects/spawn-object-custom.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Spawn Object - Custom"},sidebar:"docs",previous:{title:"Spawn Object",permalink:"/Mirage/docs/guides/game-objects/spawn-object"},next:{title:"Spawn Object - Pooling",permalink:"/Mirage/docs/guides/game-objects/spawn-object-pooling"}},l={},p=[{value:"Setting Up a Game Object Pool with Custom Spawn Handlers",id:"setting-up-a-game-object-pool-with-custom-spawn-handlers",level:2},{value:"Dynamic spawning",id:"dynamic-spawning",level:2}],c={toc:p};function d(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"custom-spawn-functions"},"Custom Spawn Functions"),(0,s.kt)("p",null,"You can use spawn handler functions to customize the default behavior when creating spawned game objects on the client. Spawn handler functions ensure you have full control of how you spawn the game object, as well as how you destroy it."),(0,s.kt)("p",null,"Use ",(0,s.kt)("inlineCode",{parentName:"p"},"ClientObjectManager.RegisterSpawnHandler")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"ClientObjectManager.RegisterPrefab")," to register functions to spawn and destroy client game objects. The server creates game objects directly and then spawns them on the clients through this functionality. This function takes either the asset ID or a prefab and two function delegates: one to handle creating game objects on the client, and one to handle destroying game objects on the client. The asset ID can be a dynamic one, or just the asset ID found on the prefab game object you want to spawn."),(0,s.kt)("p",null,"The spawn/unspawn delegates will look something like this:"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Spawn Handler")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"NetworkIdentity SpawnDelegate(SpawnMessage msg) \n{\n    // do stuff here\n}\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"UnSpawn Handler")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"void UnSpawnDelegate(NetworkIdentity spawned) \n{\n    // do stuff here\n}\n")),(0,s.kt)("p",null,"When a prefab is saved its ",(0,s.kt)("inlineCode",{parentName:"p"},"PrefabHash")," field will be automatically set. If you want to create prefabs at runtime you will have to generate a new Hash instead."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Generate prefab at runtime")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs"},'// Create a hash that can be generated on both server and client\n// using a string and GetStableHashCode is a good way to do this\nint coinHash = "MyCoin".GetStableHashCode();\n\n// register handlers using hash\nClientObjectManager.RegisterSpawnHandler(coinHash, SpawnCoin, UnSpawnCoin);\n')),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The unspawn function may be left as ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),", Mirage will then call ",(0,s.kt)("inlineCode",{parentName:"p"},"GameObject.Destroy")," when the destroy message is received.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Use existing prefab")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"// register handlers using prefab\nClientObjectManager.RegisterPrefab(coin, SpawnCoin, UnSpawnCoin);\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Spawn on Server")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs"},'int coinHash = "MyCoin".GetStableHashCode();\n\n// spawn a coin - SpawnCoin is called on client\n// pass in coinHash so that it is set on the Identity before it is sent to client\nNetworkServer.Spawn(gameObject, coinHash);\n')),(0,s.kt)("p",null,"The spawn functions themselves are implemented with the delegate signature. Here is the coin spawner. The ",(0,s.kt)("inlineCode",{parentName:"p"},"SpawnCoin")," would look the same, but have different spawn logic:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"public NetworkIdentity SpawnCoin(SpawnMessage msg)\n{\n    return Instantiate(m_CoinPrefab, msg.position, msg.rotation);\n}\npublic void UnSpawnCoin(NetworkIdentity spawned)\n{\n    Destroy(spawned);\n}\n")),(0,s.kt)("p",null,"When using custom spawn functions, it is sometimes useful to be able to unspawn game objects without destroying them. This can be done by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"NetworkServer.Destroy(identity, destroyServerObject: false)"),", making sure that the 2nd argument is false. This causes the object to be ",(0,s.kt)("inlineCode",{parentName:"p"},"Reset")," on the server and sends a ",(0,s.kt)("inlineCode",{parentName:"p"},"ObjectDestroyMessage")," to clients. The ",(0,s.kt)("inlineCode",{parentName:"p"},"ObjectDestroyMessage")," will cause the custom unspawn function to be called on the clients. If there is no unspawn function the object will instead be ",(0,s.kt)("inlineCode",{parentName:"p"},"Destroy")),(0,s.kt)("p",null,"Note that on the host, game objects are not spawned for the local client, because they already exist on the server. This also means that no spawn or unspawn handler functions are called."),(0,s.kt)("h2",{id:"setting-up-a-game-object-pool-with-custom-spawn-handlers"},"Setting Up a Game Object Pool with Custom Spawn Handlers"),(0,s.kt)("p",null,"you can use custom spawn handlers in order set up object pooling so you dont need to instantiate and destroy objects each time you use them. "),(0,s.kt)("p",null,"A full guide on pooling can be found here: ",(0,s.kt)("a",{parentName:"p",href:"./spawn-object-pooling"},"Spawn Object Pooling")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs"},"void ClientConnected() \n{\n    clientObjectManager.RegisterPrefab(prefab, PoolSpawnHandler, PoolUnspawnHandler);\n}\n\n// used by clientObjectManager.RegisterPrefab\nNetworkIdentity PoolSpawnHandler(SpawnMessage msg)\n{\n    return GetFromPool(msg.position, msg.rotation);\n}\n\n// used by clientObjectManager.RegisterPrefab\nvoid PoolUnspawnHandler(NetworkIdentity spawned)\n{\n    PutBackInPool(spawned);\n}\n")),(0,s.kt)("h2",{id:"dynamic-spawning"},"Dynamic spawning"),(0,s.kt)("p",null,"Some times you may want to create objects at runtime and you might not know the prefab hash ahead of time. For this you can use Dynamic Spawn Handlers to return a spawn handler for a prefab hash."),(0,s.kt)("p",null,"Below is an example where client pre-spawns objects while loading, and then network spawns them when receiving a ",(0,s.kt)("inlineCode",{parentName:"p"},"SpawnMessage")," from server."),(0,s.kt)("p",null,"Dynamic Handler avoid the need to add 1 spawn handler for each prefab hash. Instead you can just add a single dynamic handler that can then be used to find and return objects."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs"},'public class DynamicSpawning : MonoBehaviour\n {\n     public ServerObjectManager ServerObjectManager;\n     public ClientObjectManager ClientObjectManager;\n\n     // used to check if a prefabHash is for a pre-spawned object\n     // we use a high bit to avoid collisions with other hashes\n     private const int PRE_SPAWN_HASH_BIT = 1 << 30;\n\n     // store handler in field so that you dont need to allocate a new one for each DynamicSpawn call\n     private SpawnHandler _handler;\n     private List<NetworkIdentity> _preSpawnedObjects = new List<NetworkIdentity>();\n\n     // call this on server to spawn objects and send spawn message to client\n     public void SpawnOnServer()\n     {\n         // set up local objects\n         SpawnLocal();\n\n         // send spawn message\n         for (var i = 0; i < _preSpawnedObjects.Count; i++)\n         {\n             var prefabHash = PRE_SPAWN_HASH_BIT | i;\n             // send index as prefabHash\n             ServerObjectManager.Spawn(_preSpawnedObjects[i], prefabHash: prefabHash);\n         }\n     }\n\n     // call this on client to spawn object and set up handler to receive spawn message \n     public void SpawnOnClient()\n     {\n         // set up local objects\n         SpawnLocal();\n\n         // register handler so client can find objects when server sends spawn message\n         _handler = new SpawnHandler(FindPreSpawnedObject, null);\n         ClientObjectManager.RegisterDynamicSpawnHandler(DynamicSpawn);\n     }\n\n     private void SpawnLocal()\n     {\n         // fill _preSpawnedObjects here with objects\n         // these can be prefabs or other objects you want to find\n         _preSpawnedObjects.Add(new GameObject("object 1").AddComponent<NetworkIdentity>());\n         _preSpawnedObjects.Add(new GameObject("object 2").AddComponent<NetworkIdentity>());\n     }\n\n     private SpawnHandler DynamicSpawn(int prefabHash)\n     {\n         // this will run for all SpawnMessages, so we must first check if this prefabHash is one we want to handle\n         if (IsPreSpawnedId(prefabHash))\n             // return a handler that is using FindPreSpawnedObject\n             return _handler;\n         else\n             return null;\n     }\n\n     private bool IsPreSpawnedId(int prefabHash)\n     {\n         // check if high bit is set (if this is not set, it is for sure not part of our list)\n         if ((prefabHash & PRE_SPAWN_HASH_BIT) == 0)\n             return false;\n\n         // if high bit is set, then the rest of the bits are the index\n         var index = prefabHash & ~PRE_SPAWN_HASH_BIT;\n\n         // NOTE: prefabHash could still randomly be from prefab at this point, check its against the _preSpawnedObjects count\n         //       it is highly unlikely that a random hash will be small and under _preSpawnedObjects\n         // check if index is in range of our pre-spawned list\n         return index < _preSpawnedObjects.Count;\n     }\n\n     // finds object based on hash and returns it\n     public NetworkIdentity FindPreSpawnedObject(SpawnMessage spawnMessage)\n     {\n         var prefabHash = spawnMessage.PrefabHash.Value;\n         // remove high bit to get index\n         var index = prefabHash & ~PRE_SPAWN_HASH_BIT;\n\n         var identity = _preSpawnedObjects[index];\n         return identity;\n     }\n }\n')))}d.isMDXComponent=!0}}]);