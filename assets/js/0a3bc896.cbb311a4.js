"use strict";(self.webpackChunkmirage_docs=self.webpackChunkmirage_docs||[]).push([[2391],{3905:(e,r,n)=>{n.d(r,{Zo:()=>p,kt:()=>m});var t=n(67294);function a(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function i(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?i(Object(n),!0).forEach((function(r){a(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function l(e,r){if(null==e)return{};var n,t,a=function(e,r){if(null==e)return{};var n,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],r.indexOf(n)>=0||(a[n]=e[n]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=t.createContext({}),c=function(e){var r=t.useContext(s),n=r;return e&&(n="function"==typeof e?e(r):o(o({},r),e)),n},p=function(e){var r=c(e.components);return t.createElement(s.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},d=t.forwardRef((function(e,r){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,g=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?t.createElement(g,o(o({ref:r},p),{},{components:n})):t.createElement(g,o({ref:r},p))}));function m(e,r){var n=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in r)hasOwnProperty.call(r,s)&&(l[s]=r[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},46939:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var t=n(87462),a=(n(67294),n(3905));const i={sidebar_position:15},o="Error Handling",l={unversionedId:"guides/error-handling",id:"guides/error-handling",title:"Error Handling",description:"Mirage includes a robust error handling system to manage issues caused by players, such as invalid messages or exploits. This system helps protect your server from crashes and allows for custom logic to handle problematic players.",source:"@site/docs/guides/error-handling.md",sourceDirName:"guides",slug:"/guides/error-handling",permalink:"/Mirage/docs/guides/error-handling",draft:!1,editUrl:"https://github.com/MirageNet/Mirage/tree/main/doc/docs/guides/error-handling.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15},sidebar:"docs",previous:{title:"FAQ",permalink:"/Mirage/docs/guides/faq"},next:{title:"Overview",permalink:"/Mirage/docs/guides/development-servers/"}},s={},c=[{value:"Overview",id:"overview",level:2},{value:"Player Error Flags",id:"player-error-flags",level:2},{value:"Server Configuration",id:"server-configuration",level:2},{value:"How Error Rate Limiting Works",id:"how-error-rate-limiting-works",level:3},{value:"Manual Error Reporting",id:"manual-error-reporting",level:2},{value:"Custom Error Example",id:"custom-error-example",level:3},{value:"Critical Error Example",id:"critical-error-example",level:3},{value:"ServerRpc Without Authority (with Sender)",id:"serverrpc-without-authority-with-sender",level:3},{value:"Custom Error Handling",id:"custom-error-handling",level:2}],p={toc:c};function u(e){let{components:r,...n}=e;return(0,a.kt)("wrapper",(0,t.Z)({},p,n,{components:r,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"error-handling"},"Error Handling"),(0,a.kt)("p",null,"Mirage includes a robust error handling system to manage issues caused by players, such as invalid messages or exploits. This system helps protect your server from crashes and allows for custom logic to handle problematic players."),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The server tracks errors caused by player actions, like malformed RPCs. If a player accumulates too many errors within a certain timeframe,  they can be automatically disconnected or handled by a custom callback."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"This rate-limiting system is server-side only and replaces the old ",(0,a.kt)("inlineCode",{parentName:"p"},"DisconnectOnException")," functionality on the server. The client still has a simple ",(0,a.kt)("inlineCode",{parentName:"p"},"DisconnectOnException")," toggle for its own error handling.")),(0,a.kt)("h2",{id:"player-error-flags"},"Player Error Flags"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"PlayerErrorFlags")," enum helps categorize the types of errors a player can cause, allowing for more granular tracking and response."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"// see PlayerErrorFlags in the source code for most up-to-date values\n[Flags]\npublic enum PlayerErrorFlags\n{\n    None = 0,\n\n    // Likely developer bugs\n    RpcNullException = 1 << 0,\n    RpcException = 1 << 1,\n\n    // Connection/versioning issues\n    DeserializationException = 1 << 2,\n    RpcSync = 1 << 3,\n    RateLimit = 1 << 4,\n\n    // Security/Malicious Intent\n    Unauthorized = 1 << 5,\n    Critical = 1 << 6,\n    LikelyCheater = 1 << 7,\n\n    // Custom developer defined errors\n    CustomError = 1 << 16\n}\n")),(0,a.kt)("p",null,"You can use these flags to identify an error's cause when implementing custom logic. You can also define your own flags using the ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomError")," bit as a starting point:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class MyErrorFlags \n{\n    public const PlayerErrorFlags InvalidTrade = PlayerErrorFlags.CustomError << 0;\n    public const PlayerErrorFlags AnotherCustom = PlayerErrorFlags.CustomError << 1;\n}\n")),(0,a.kt)("h2",{id:"server-configuration"},"Server Configuration"),(0,a.kt)("h3",{id:"how-error-rate-limiting-works"},"How Error Rate Limiting Works"),(0,a.kt)("p",null,'Mirage uses a token bucket algorithm to manage player errors. Each player has a "bucket" of tokens that represents their error budget.'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Tokens"),": When a player causes an error, a ",(0,a.kt)("inlineCode",{parentName:"p"},"cost")," is deducted from their token bucket.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Max Tokens"),": The capacity of the bucket. A player starts with this many tokens and cannot exceed this limit. A higher limit allows for a burst of errors, for example if something goes wrong in the game for a short amount of time.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Refill & Interval"),": Tokens are replenished over time. ",(0,a.kt)("inlineCode",{parentName:"p"},"Refill")," specifies how many tokens are restored every ",(0,a.kt)("inlineCode",{parentName:"p"},"Interval")," (in seconds).")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Cost"),": Represents the severity of an error. When an error occurs, this amount is subtracted from the player's tokens.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Reaching the Limit"),": If a player's token count drops below zero, they have exhausted their budget. This triggers the error handling logic, which is a disconnect by default."))),(0,a.kt)("p",null,"This system tolerates occasional minor errors while penalizing frequent or severe infractions."),(0,a.kt)("p",null,"On the ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkServer")," component, you can configure this behavior:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Error Rate Limit Enabled"),": Toggles the rate-limiting feature. Enabled by default."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Error Rate Limit Config"),": Configures the token bucket (",(0,a.kt)("inlineCode",{parentName:"li"},"MaxTokens"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Refill"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Interval"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Rethrow Exception"),": If enabled, exceptions are re-thrown after being logged. This is for debugging and can interrupt server operations.")),(0,a.kt)("h2",{id:"manual-error-reporting"},"Manual Error Reporting"),(0,a.kt)("p",null,"You can manually trigger an error for a player from server-side code using ",(0,a.kt)("inlineCode",{parentName:"p"},"INetworkPlayer.SetError"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"cost")," parameter specifies how many tokens to subtract from the player's error bucket. A higher cost leads to faster rate-limiting. Setting a cost higher than the player's current tokens (or even ",(0,a.kt)("inlineCode",{parentName:"p"},"MaxTokens"),") will trigger the error limit immediately."),(0,a.kt)("h3",{id:"custom-error-example"},"Custom Error Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class MyErrorFlags \n{\n    public const PlayerErrorFlags InvalidAction = PlayerErrorFlags.CustomError << 0;\n}\n\n// ... inside a NetworkBehaviour\n[ServerRpc]\nvoid CmdDoSomething(int data)\n{\n    // The IsActionValid method would contain your custom validation logic.\n    if (!IsActionValid(data))\n    {\n        // Penalize the player with a moderate cost for sending invalid data.\n        Owner.SetError(10, MyErrorFlags.InvalidAction);\n        return;\n    }\n\n    // ... process valid data\n}\n")),(0,a.kt)("h3",{id:"critical-error-example"},"Critical Error Example"),(0,a.kt)("p",null,"For severe violations, use ",(0,a.kt)("inlineCode",{parentName:"p"},"PlayerErrorFlags.Critical")," with a high cost to trigger the handler instantly."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[ServerRpc]\nvoid CmdTryAdminAction(string command)\n{\n    // The IsAdmin method would check if the player has admin privileges.\n    if (!IsAdmin(Owner))\n    {\n        // A non-admin tried to use an admin command.\n        // Set cost higher than MaxTokens (default 200) to trigger the limit immediately.\n        Owner.SetError(10000, PlayerErrorFlags.Critical);\n        return;\n    }\n\n    // ... execute admin command\n}\n")),(0,a.kt)("h3",{id:"serverrpc-without-authority-with-sender"},"ServerRpc Without Authority (with Sender)"),(0,a.kt)("p",null,"Sometimes you need a ",(0,a.kt)("inlineCode",{parentName:"p"},"ServerRpc")," to be callable from any client, not just the owner of the ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkBehaviour"),", and you need to know which client sent the RPC. Use ",(0,a.kt)("inlineCode",{parentName:"p"},"requireAuthority = false")," and include ",(0,a.kt)("inlineCode",{parentName:"p"},"INetworkPlayer sender = null")," as a parameter."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[Client]\npublic void SendPublicMessage(string message) \n{\n    // client side check before sending message\n    if (string.IsNullOrWhiteSpace(message) || message.Length > 100)\n        return;\n\n    CmdSendPublicMessage(message)\n}\n\n[ServerRpc(requireAuthority = false)]\nvoid CmdSendPublicMessage(string message, INetworkPlayer sender = null)\n{\n    if (string.IsNullOrWhiteSpace(message) || message.Length > 100)\n    {\n        // Invalid message length. this is very likely a cheat because message length is checked on client before\n        // how ever this is just chat message nothing not critical gameplay\n        // for example could be from chat mod with higher size that they left on after playing on a modded server\n        sender.SetError(50, PlayerErrorFlags.LikelyCheater); \n        return;\n    }\n\n    if (CheckMessageRateLimit(sender)) \n    {\n        // player sent more message than chat rate limit, just use low cost\n        sender.SetError(1, PlayerErrorFlags.None); \n        return;\n    }\n\n    // ...\n}\n")),(0,a.kt)("h2",{id:"custom-error-handling"},"Custom Error Handling"),(0,a.kt)("p",null,"Instead of the default disconnect, you can define a custom callback to execute when a player reaches their error limit using ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkServer.SetErrorRateLimitReachedCallback"),"."),(0,a.kt)("p",null,"This callback is best used alongside ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkAuthenticator")," so that you can ban or timeout users, stopping them from reconnecting."),(0,a.kt)("p",null,"You can check ",(0,a.kt)("inlineCode",{parentName:"p"},"player.ErrorFlags")," to see how important the errors have been."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'using Mirage;\nusing UnityEngine;\n\npublic class MyGameServer : MonoBehaviour\n{\n    public NetworkServer server;\n\n    void Start()\n    {\n        server.SetErrorRateLimitReachedCallback(OnPlayerErrorLimitReached);\n    }\n\n    void OnPlayerErrorLimitReached(INetworkPlayer player)\n    {\n        Debug.LogWarning($"Player {player} reached error limit with flags: {player.ErrorFlags}");\n\n        if ((player.ErrorFlags & PlayerErrorFlags.Critical) != 0)\n        {\n            // For critical errors, always disconnect.\n            player.Disconnect();\n            \n            // ... add player to ban or timeout list here so they can\'t reconnect\n            \n            return;\n        }\n        else if ((player.ErrorFlags & MyErrorFlags.InvalidAction) != 0)\n        {\n            // For our custom action, maybe just send a warning.\n            // Note: You would need to implement the ChatMessage struct and its handler.\n            // player.Send(new ChatMessage("You are performing too many invalid actions."));\n        }\n        // ... other custom logic\n\n        // Reset flags after handling\n        player.ResetErrorFlag();\n    }\n}\n')))}u.isMDXComponent=!0}}]);