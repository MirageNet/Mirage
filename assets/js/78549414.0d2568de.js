"use strict";(self.webpackChunkmirage_docs=self.webpackChunkmirage_docs||[]).push([[7035],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),d=p(n),h=a,g=d["".concat(c,".").concat(h)]||d[h]||u[h]||i;return n?r.createElement(g,l(l({ref:t},s),{},{components:n})):r.createElement(g,l({ref:t},s))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},88009:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const i={sidebar_position:2},l="Client RPC",o={unversionedId:"guides/remote-actions/client-rpc",id:"guides/remote-actions/client-rpc",title:"Client RPC",description:"ClientRpcs are sent from NetworkBehaviours on the server to Behaviours on the client. They can be sent from any NetworkBehaviour that has been spawned.",source:"@site/docs/guides/remote-actions/client-rpc.md",sourceDirName:"guides/remote-actions",slug:"/guides/remote-actions/client-rpc",permalink:"/Mirage/docs/guides/remote-actions/client-rpc",draft:!1,editUrl:"https://github.com/MirageNet/Mirage/tree/main/doc/docs/guides/remote-actions/client-rpc.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"Overview",permalink:"/Mirage/docs/guides/remote-actions/"},next:{title:"Server RPC",permalink:"/Mirage/docs/guides/remote-actions/server-rpc"}},c={},p=[{value:"RpcTarget",id:"rpctarget",level:2},{value:"RpcTarget.Observers",id:"rpctargetobservers",level:3},{value:"RpcTarget.Owner",id:"rpctargetowner",level:3},{value:"RpcTarget.Player",id:"rpctargetplayer",level:3},{value:"Exclude owner",id:"exclude-owner",level:2},{value:"Channel",id:"channel",level:2},{value:"Returning values",id:"returning-values",level:3}],s={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"client-rpc"},"Client RPC"),(0,a.kt)("p",null,"ClientRpcs are sent from ",(0,a.kt)("a",{parentName:"p",href:"/docs/reference/Mirage/NetworkBehaviour"},"NetworkBehaviours")," on the server to Behaviours on the client. They can be sent from any ",(0,a.kt)("a",{parentName:"p",href:"/docs/reference/Mirage/NetworkBehaviour"},"NetworkBehaviour")," that has been spawned."),(0,a.kt)("p",null,"To make a function into a ClientRpc add ",(0,a.kt)("a",{parentName:"p",href:"/docs/reference/Mirage/ClientRpcAttribute"},(0,a.kt)("inlineCode",{parentName:"a"},"[ClientRpc]"))," directly above the function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"[ClientRpc]\npublic void MyRpcFunction() \n{\n    // Code to invoke on client\n}\n")),(0,a.kt)("p",null,"ClientRpc functions can't be static and must return ",(0,a.kt)("inlineCode",{parentName:"p"},"void"),"."),(0,a.kt)("h2",{id:"rpctarget"},"RpcTarget"),(0,a.kt)("p",null,"There are 3 target modes for ClientRpc:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Observers (default)"),(0,a.kt)("li",{parentName:"ul"},"Owner"),(0,a.kt)("li",{parentName:"ul"},"Player")),(0,a.kt)("h3",{id:"rpctargetobservers"},"RpcTarget.Observers"),(0,a.kt)("p",null,"This is the default target."),(0,a.kt)("p",null,"This will send the RPC message to only the observers of an object according to its ",(0,a.kt)("a",{parentName:"p",href:"/docs/guides/network-visibility"},"Network Visibility"),". If there is no Network Visibility on the object it will send to all players."),(0,a.kt)("h3",{id:"rpctargetowner"},"RpcTarget.Owner"),(0,a.kt)("p",null,"This will send the RPC message to only the owner of the object."),(0,a.kt)("h3",{id:"rpctargetplayer"},"RpcTarget.Player"),(0,a.kt)("p",null,"This will send the RPC message to the ",(0,a.kt)("a",{parentName:"p",href:"/docs/reference/Mirage/NetworkPlayer"},(0,a.kt)("inlineCode",{parentName:"a"},"NetworkPlayer"))," that is passed into the call."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},"[ClientRpc(target = RpcTarget.Player)]\npublic void MyRpcFunction(NetworkPlayer target) \n{\n    // Code to invoke on client\n}\n")),(0,a.kt)("p",null,"Mirage will use the ",(0,a.kt)("inlineCode",{parentName:"p"},"NetworkPlayer target")," to know where to send it, but it will not send the ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," value. Because of this, its value will always be null for the client."),(0,a.kt)("h2",{id:"exclude-owner"},"Exclude owner"),(0,a.kt)("p",null,"You may want to exclude the owner client when calling a ClientRpc. This is done with the ",(0,a.kt)("inlineCode",{parentName:"p"},"excludeOwner")," option: ",(0,a.kt)("inlineCode",{parentName:"p"},"[ClientRpc(excludeOwner = true)]"),"."),(0,a.kt)("h2",{id:"channel"},"Channel"),(0,a.kt)("p",null,"RPC can be sent using either the Reliable or Unreliable channels. ",(0,a.kt)("inlineCode",{parentName:"p"},"[ClientRpc(channel = Channel.Reliable)]")),(0,a.kt)("h3",{id:"returning-values"},"Returning values"),(0,a.kt)("p",null,"ClientRpcs can return values only if RpcTarget is ",(0,a.kt)("inlineCode",{parentName:"p"},"Player")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Owner"),". It can take a long time for the client to reply, so they must return a UniTask which the server can await."),(0,a.kt)("p",null,"To return a value, add a return value using ",(0,a.kt)("inlineCode",{parentName:"p"},"UniTask<MyReturnType>")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"MyReturnType")," is any ",(0,a.kt)("a",{parentName:"p",href:"/docs/guides/serialization/data-types"},"supported Mirage type"),". In the client, you can make your method async,  or you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"UniTask.FromResult(myResult);"),". For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},'public class SelectCharacter : NetworkBehaviour\n {\n     // need to target owner so that we can reply to them\n     [ClientRpc(target = RpcTarget.Owner)]\n     public UniTask<string> GetCharacter()\n     {\n         // return the name of the character that the user selected\n         return UniTask.FromResult("myCharacter");\n     }\n\n     [Client]\n     public async UniTaskVoid WaitForPlayerToSelectCharacter()\n     {\n         // Call the RPC and wait for the response without blocking the main thread\n         var characterName = await GetCharacter();\n\n         Debug.Log($"Selected Character {characterName}");\n     }\n }\n')),(0,a.kt)("h1",{id:"examples"},"Examples"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},'public class Player : NetworkBehaviour\n{\n    private int health;\n\n    public void TakeDamage(int amount)\n    {\n        if (!IsServer)\n        {\n            return;\n        }\n\n        health -= amount;\n        Damage(amount);\n    }\n\n    [ClientRpc]\n    private void Damage(int amount)\n    {\n        Debug.Log("Took damage:" + amount);\n    }\n}\n')),(0,a.kt)("p",null,"When running a game as a host with a local client, ClientRpc calls will be invoked on the local client even though it is in the same process as the server. So the behaviors of local and remote clients are the same for ClientRpc calls."),(0,a.kt)("p",null,"You can also specify which client gets the call with the ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," parameter. "),(0,a.kt)("p",null,"If you only want the client that owns the object to be called,  use ",(0,a.kt)("inlineCode",{parentName:"p"},"[ClientRpc(target = RpcTarget.Owner)]")," or you can specify which client gets the message by using ",(0,a.kt)("inlineCode",{parentName:"p"},"[ClientRpc(target = RpcTarget.Player)]")," and passing the player as a parameter.  For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cs"},'public class Player : NetworkBehaviour\n{\n    private int health;\n\n    [Server]\n    private void Magic(GameObject target, int damage)\n    {\n        target.GetComponent<Player>().health -= damage;\n\n        NetworkIdentity opponentIdentity = target.GetComponent<NetworkIdentity>();\n        DoMagic(opponentIdentity.Owner, damage);\n    }\n\n    [ClientRpc(target = RpcTarget.Player)]\n    public void DoMagic(INetworkPlayer target, int damage)\n    {\n        // This will appear on the opponent\'s client, not the attacking player\'s\n        Debug.Log($"Magic Damage = {damage}");\n    }\n\n    [Server]\n    private void HealMe()\n    {\n        health += 10;\n        Healed(10);\n    }\n\n    [ClientRpc(target = RpcTarget.Owner)]\n    public void Healed(int amount)\n    {\n        // No NetworkPlayer parameter, so it goes to owner\n        Debug.Log($"Health increased by {amount}");\n    }\n}\n')))}u.isMDXComponent=!0}}]);